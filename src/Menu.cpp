/***********************************************************************/
/*                                                                     */
/*  FILE        :Menu.cpp                                              */
/*  DATE        :Apl 21, 2021                                          */
/*  DESCRIPTION :メニュー表示クラス                                    */
/*                                                                     */
/*  This file is generated by Tatsuya Miyazaki                         */
/*                                                                     */
/***********************************************************************/

#include "Menu.h"

/***********************************************************************/
/*                          メニュー表示クラス                          */
/***********************************************************************/
/* menu[] 配列の中身の個数を返す。 */
uint8_t Menu::countMenu(const menuType me[]) {
  uint8_t i;
  for (i = 0; me[i].function != END; i++);
  return (i);
}

/* menuリストを初期化し、gMenuCharを設定する*/
Menu::Menu(const menuType *menu, char menuChar) {
  gMenu = menu;
  gMenuNum = countMenu(menu);
  gMenuChar = menuChar;
  lastMode = 0;
}

Menu::~Menu() { ; }

/* 引数の関数が何番目かを返す関数 */
uint8_t Menu::getMenuNum(void (*f)(uint8_t *)) {
  uint8_t i;
  const menuType *me = gMenu;
  for (i = 0; me->function != f; i++, me++);
  return (i);
}

String Menu::mygets(void) {
  String inputString = "";
  while (Serial.read() != -1) {
    delay(100);
  }  // 受信バッファをクリア
  while (1) {
    if (Serial.available()) {
      char c = Serial.read();
      if (c == '\n' || c == '\r') {
        return inputString;
      } else {
        inputString += String(c);
        Serial.write(c);
      }
    }
    delay(100);
  }
}

void Menu::flush(void) {
  while (Serial.read() != -1) {
    delay(100);
  }
}

/* 動作モードをスキャンする関数 */
void Menu::scanMode(uint8_t *md) {
  uint8_t i;
  const menuType *me = gMenu;

  *md = 0;
  Serial.print("\r\r\r\n");
  Serial.print("# ------------------------ menu -------------------------\n\r");
  for (i = 0; me->function != END; i++, me++) {
    Serial.print("# " + String(i) + ": " + String(me->name) + "\n\r");
  }
  Serial.print("# -------------------------------------------------------\n\r");
  Serial.print("# \n\r");
  Serial.print("# You want to : ");
  while (Serial.read() != -1) {
    delay(100);
  }
  String input = mygets();
  if (input.length() > 0) {
    *md = (uint8_t)input.toInt();
  }
  Serial.print("\n\r");
}

/* 実行するモードを得る関数 */
void Menu::getMode(uint8_t *md, char com) {
  /* gMenuCharが押されればMenu表示 */
  if (com == gMenuChar) {
    scanMode(md);
  }
  /* ショートカットキーが押されればそれに対応するモードへ切り替える */
  else {
    uint8_t i;
    const menuType *me = gMenu;
    for (i = 0; me->function != END; i++, me++) {
      if ((com == me->shortcutkey) && (com != '\0')) {
        *md = getMenuNum(me->function);
        return;
      }
    }
  }
}

/* modeを実行する関数。 */
void Menu::exeMode(uint8_t *md) {
  const menuType *me = gMenu;

  /* 現在のmodeに対応する関数を実行 */
  if (*md < gMenuNum) {
    me[*md].function(md);
  } else {
    *md = 0;
  }
}

/* メニュー機能を実現する関数 */
uint8_t Menu::menuApp(char com) {
  uint8_t mode;
  getMode(&mode, com);
  exeMode(&mode);
  return (mode);
}

/* 設定されているショートカットを表示する */
void Menu::printShortcuts(void) {
  const menuType *me = gMenu;

  Serial.print("\n\r# =================== Short cuts ===================\n\r");
  for (; me->function != END; me++) {
    if (me->shortcutkey)
      Serial.print("#   '" + String(me->shortcutkey) +
                   "'  : " + String(me->name) + "\n\r");
  }
  Serial.print("#   '" + String(gMenuChar) + "'  : menu\n\r");
  Serial.print("# ==================================================\n\r\n");
}

/* モードが切り替わった最初だけ1を返す関数 */
uint8_t Menu::isFirstAccess(uint8_t md) {
  if (md == lastMode) {
    return (0);
  } else {
    lastMode = md;
    return (1);
  }
}

/* 一つ前のモードを返す */
uint8_t Menu::getLastMode(void) { return (lastMode); }
